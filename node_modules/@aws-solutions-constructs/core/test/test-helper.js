"use strict";
/**
 *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance
 *  with the License. A copy of the License is located at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  or in the 'license' file accompanying this file. This file is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES
 *  OR CONDITIONS OF ANY KIND, express or implied. See the License for the specific language governing permissions
 *  and limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SuppressCfnNagLambdaWarnings = exports.CreateShortUniqueTestName = exports.CreateApiAuthorizer = exports.CreateTestApi = exports.expectNonexistence = exports.expectKmsKeyAttachedToCorrectResource = exports.CreateTestCache = exports.suppressCustomHandlerCfnNagWarnings = exports.getFakeCertificate = exports.getTestVpc = exports.generateIntegStackName = exports.CreateScrapBucket = exports.fakeEcrRepoArn = void 0;
const aws_s3_1 = require("aws-cdk-lib/aws-s3");
const aws_cdk_lib_1 = require("aws-cdk-lib");
const vpc_helper_1 = require("../lib/vpc-helper");
const vpc_defaults_1 = require("../lib/vpc-defaults");
const utils_1 = require("../lib/utils");
const elasticache_helper_1 = require("../lib/elasticache-helper");
const path = require("path");
const cache = require("aws-cdk-lib/aws-elasticache");
const ec2 = require("aws-cdk-lib/aws-ec2");
const acm = require("aws-cdk-lib/aws-certificatemanager");
const elasticache_defaults_1 = require("../lib/elasticache-defaults");
const assertions_1 = require("aws-cdk-lib/assertions");
const lambda = require("aws-cdk-lib/aws-lambda");
const api = require("aws-cdk-lib/aws-apigateway");
exports.fakeEcrRepoArn = 'arn:aws:ecr:us-east-1:123456789012:repository/fake-repo';
// Creates a bucket used for testing - minimal properties, destroyed after test
function CreateScrapBucket(scope, id, props) {
    if (props?.serverAccessLogsBucket) {
        throw new Error("Don't try to send a log bucket to CreateScrapBucket");
    }
    // Basic props for scrap and log buckets
    const defaultProps = {
        versioned: true,
        removalPolicy: aws_cdk_lib_1.RemovalPolicy.DESTROY,
        autoDeleteObjects: true,
        encryption: aws_s3_1.BucketEncryption.S3_MANAGED,
        enforceSSL: true
    };
    // Create basic log bucket
    const logBucket = new aws_s3_1.Bucket(scope, `${id}Log`, defaultProps);
    // Combine basic props with special props from test client
    let synthesizedProps;
    if (props) {
        synthesizedProps = utils_1.overrideProps(defaultProps, props);
    }
    else {
        synthesizedProps = defaultProps;
    }
    // Finally - set up logging for the scrap bucket
    const finalProps = utils_1.overrideProps(synthesizedProps, { serverAccessLogsBucket: logBucket });
    const scriptBucket = new aws_s3_1.Bucket(scope, id, finalProps);
    utils_1.addCfnSuppressRules(logBucket, [
        {
            id: "W35",
            reason: "This is a log bucket",
        }
    ]);
    return scriptBucket;
}
exports.CreateScrapBucket = CreateScrapBucket;
/**
 * @summary Creates a stack name for Integration tests
 * @param {string} filename - the filename of the integ test
 * @returns {string} - a string with current filename after removing anything before the prefix '.' and suffix '.js'
 * e.g. 'integ.apigateway-dynamodb-CRUD.js' will return 'apigateway-dynamodb-CRUD'
 */
function generateIntegStackName(filename) {
    const file = path.basename(filename, path.extname(filename));
    const stackname = file.slice(file.lastIndexOf('.') + 1).replace(/_/g, '-');
    return stackname;
}
exports.generateIntegStackName = generateIntegStackName;
// Helper Functions
function getTestVpc(stack, publicFacing = true, userVpcProps) {
    return vpc_helper_1.buildVpc(stack, {
        defaultVpcProps: publicFacing ?
            vpc_defaults_1.DefaultPublicPrivateVpcProps() :
            vpc_defaults_1.DefaultIsolatedVpcProps(),
        constructVpcProps: {
            enableDnsHostnames: true,
            enableDnsSupport: true,
            ipAddresses: ec2.IpAddresses.cidr('172.168.0.0/16'),
        },
        userVpcProps
    });
}
exports.getTestVpc = getTestVpc;
function getFakeCertificate(scope, id) {
    return acm.Certificate.fromCertificateArn(scope, id, "arn:aws:acm:us-east-1:123456789012:certificate/11112222-3333-1234-1234-123456789012");
}
exports.getFakeCertificate = getFakeCertificate;
function suppressCustomHandlerCfnNagWarnings(stack, handlerId) {
    stack.node.children.forEach(child => {
        if (child.node.id === handlerId) {
            const handlerFunction = child.node.findChild('Handler');
            utils_1.addCfnSuppressRules(handlerFunction, [{ id: "W58", reason: "CDK generated custom resource" }]);
            utils_1.addCfnSuppressRules(handlerFunction, [{ id: "W89", reason: "CDK generated custom resource" }]);
            utils_1.addCfnSuppressRules(handlerFunction, [{ id: "W92", reason: "CDK generated custom resource" }]);
        }
    });
}
exports.suppressCustomHandlerCfnNagWarnings = suppressCustomHandlerCfnNagWarnings;
function CreateTestCache(scope, id, vpc, port) {
    const cachePort = port ?? elasticache_defaults_1.GetDefaultCachePort();
    // Create the subnet group from all the isolated subnets in the VPC
    const subnetGroup = elasticache_helper_1.createCacheSubnetGroup(scope, vpc, id);
    const emptySG = new ec2.SecurityGroup(scope, `${id}-cachesg`, {
        vpc,
        allowAllOutbound: true,
    });
    utils_1.addCfnSuppressRules(emptySG, [{ id: "W40", reason: "Test Resource" }]);
    utils_1.addCfnSuppressRules(emptySG, [{ id: "W5", reason: "Test Resource" }]);
    utils_1.addCfnSuppressRules(emptySG, [{ id: "W36", reason: "Test Resource" }]);
    const cacheProps = {
        clusterName: `${id}-cdk-cluster`,
        cacheNodeType: "cache.t3.medium",
        engine: "memcached",
        numCacheNodes: 2,
        port: cachePort,
        azMode: "cross-az",
        vpcSecurityGroupIds: [emptySG.securityGroupId],
        cacheSubnetGroupName: subnetGroup.cacheSubnetGroupName,
    };
    const newCache = new cache.CfnCacheCluster(scope, `${id}-cluster`, cacheProps);
    newCache.addDependency(subnetGroup);
    return newCache;
}
exports.CreateTestCache = CreateTestCache;
/**
 * Asserts that a KMS key with a specific description exists on a resource
 *
 * @param stack The CloudFormation Stack that contains the to validate.
 * @param parentResourceType The type of CloudFormation Resource that should have the key set on it, e.g., `AWS::SNS::Topic`, etc...
 * @param description The value of the Description property on the KMS Key
 */
function expectKmsKeyAttachedToCorrectResource(stack, parentResourceType, keyDescription) {
    const template = assertions_1.Template.fromStack(stack);
    const resource = template.findResources('AWS::KMS::Key', {
        Properties: {
            Description: assertions_1.Match.exact(keyDescription)
        }
    });
    const [logicalId] = Object.keys(resource);
    assertions_1.Template.fromStack(stack).hasResourceProperties(parentResourceType, {
        KmsMasterKeyId: {
            "Fn::GetAtt": [
                logicalId,
                "Arn"
            ]
        }
    });
}
exports.expectKmsKeyAttachedToCorrectResource = expectKmsKeyAttachedToCorrectResource;
function expectNonexistence(stack, type, props) {
    const shouldFindNothing = assertions_1.Template.fromStack(stack).findResources(type, props);
    expect(Object.keys(shouldFindNothing).length).toEqual(0);
}
exports.expectNonexistence = expectNonexistence;
// private helper class to suppress the standard cfn nag warnings for lambda functions used in integ tests
class CfnNagLambdaAspect {
    visit(node) {
        const resource = node;
        if (resource.cfnResourceType === 'AWS::Lambda::Function') {
            utils_1.addCfnSuppressRules(resource, [
                { id: 'W58', reason: 'This Lambda Function is created for integration testing purposes only and is not part of an actual construct' },
                { id: 'W89', reason: 'This Lambda Function is created for integration testing purposes only and is not part of an actual construct' },
                { id: 'W92', reason: 'This Lambda Function is created for integration testing purposes only and is not part of an actual construct' }
            ]);
        }
    }
}
function CreateTestApi(stack, id) {
    const lambdaFunction = new lambda.Function(stack, `${id}Function`, {
        code: lambda.Code.fromAsset(`${__dirname}/lambda`),
        runtime: lambda.Runtime.NODEJS_16_X,
        handler: ".handler",
    });
    utils_1.addCfnSuppressRules(lambdaFunction, [{ id: "W58", reason: "Test Resource" }]);
    utils_1.addCfnSuppressRules(lambdaFunction, [{ id: "W89", reason: "Test Resource" }]);
    utils_1.addCfnSuppressRules(lambdaFunction, [{ id: "W92", reason: "Test Resource" }]);
    const restApi = new api.LambdaRestApi(stack, `${id}Api`, {
        handler: lambdaFunction,
        defaultMethodOptions: {
            authorizationType: api.AuthorizationType.CUSTOM,
            authorizer: CreateApiAuthorizer(stack, `${id}-authorizer`)
        }
    });
    const newDeployment = restApi.latestDeployment;
    if (newDeployment) {
        utils_1.addCfnSuppressRules(newDeployment, [
            { id: "W68", reason: "Test Resource" },
        ]);
    }
    const newMethod = restApi.methods[0];
    utils_1.addCfnSuppressRules(newMethod, [{ id: "W59", reason: "Test Resource" }]);
    const newMethodTwo = restApi.methods[1];
    utils_1.addCfnSuppressRules(newMethodTwo, [{ id: "W59", reason: "Test Resource" }]);
    const newStage = restApi.deploymentStage;
    utils_1.addCfnSuppressRules(newStage, [{ id: "W64", reason: "Test Resource" }]);
    utils_1.addCfnSuppressRules(newStage, [{ id: "W69", reason: "Test Resource" }]);
    return restApi;
}
exports.CreateTestApi = CreateTestApi;
function CreateApiAuthorizer(stack, id) {
    const authFn = new lambda.Function(stack, `${id}AuthFunction`, {
        code: lambda.Code.fromAsset(`${__dirname}/lambda`),
        runtime: lambda.Runtime.NODEJS_16_X,
        handler: ".handler",
    });
    utils_1.addCfnSuppressRules(authFn, [{ id: "W58", reason: "Test Resource" }]);
    utils_1.addCfnSuppressRules(authFn, [{ id: "W89", reason: "Test Resource" }]);
    utils_1.addCfnSuppressRules(authFn, [{ id: "W92", reason: "Test Resource" }]);
    const authorizer = new api.RequestAuthorizer(stack, id, {
        handler: authFn,
        identitySources: [api.IdentitySource.header('Authorization')]
    });
    return authorizer;
}
exports.CreateApiAuthorizer = CreateApiAuthorizer;
// Create a short, unique to this stack name
// technically this is not 100% OK, as it only uses a portion of the
// stack guid - but it's for tests only so if the last segment of 2 stack guids collide someday
// (VERY unlikely), just running again should take care of it.
function CreateShortUniqueTestName(stub) {
    const stackGuid = aws_cdk_lib_1.Fn.select(2, aws_cdk_lib_1.Fn.split('/', `${aws_cdk_lib_1.Aws.STACK_ID}`));
    const guidPortion = aws_cdk_lib_1.Fn.select(4, aws_cdk_lib_1.Fn.split('-', stackGuid));
    return aws_cdk_lib_1.Fn.join("-", [stub, guidPortion]);
}
exports.CreateShortUniqueTestName = CreateShortUniqueTestName;
/**
 * Used to suppress cfn nag W58, W89, and W92 rules on lambda integration test resources.
 *
 * @param stack - The stack to suppress cfn nag lambda rules on
 */
function SuppressCfnNagLambdaWarnings(stack) {
    aws_cdk_lib_1.Aspects.of(stack).add(new CfnNagLambdaAspect());
}
exports.SuppressCfnNagLambdaWarnings = SuppressCfnNagLambdaWarnings;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC1oZWxwZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ0ZXN0LWhlbHBlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7O0dBV0c7OztBQUlILCtDQUEyRTtBQUMzRSw2Q0FBMkY7QUFDM0Ysa0RBQTZDO0FBQzdDLHNEQUE0RjtBQUM1Rix3Q0FBa0U7QUFDbEUsa0VBQW9FO0FBQ3BFLDZCQUE2QjtBQUM3QixxREFBcUQ7QUFDckQsMkNBQTJDO0FBQzNDLDBEQUEwRDtBQUUxRCxzRUFBa0U7QUFDbEUsdURBQXlEO0FBQ3pELGlEQUFpRDtBQUNqRCxrREFBa0Q7QUFFckMsUUFBQSxjQUFjLEdBQUcseURBQXlELENBQUM7QUFFeEYsK0VBQStFO0FBQy9FLFNBQWdCLGlCQUFpQixDQUFDLEtBQWdCLEVBQUUsRUFBVSxFQUFFLEtBQXlCO0lBRXZGLElBQUksS0FBSyxFQUFFLHNCQUFzQixFQUFFO1FBQ2pDLE1BQU0sSUFBSSxLQUFLLENBQUMscURBQXFELENBQUMsQ0FBQztLQUN4RTtJQUVELHdDQUF3QztJQUN4QyxNQUFNLFlBQVksR0FBZ0I7UUFDaEMsU0FBUyxFQUFFLElBQUk7UUFDZixhQUFhLEVBQUUsMkJBQWEsQ0FBQyxPQUFPO1FBQ3BDLGlCQUFpQixFQUFFLElBQUk7UUFDdkIsVUFBVSxFQUFFLHlCQUFnQixDQUFDLFVBQVU7UUFDdkMsVUFBVSxFQUFFLElBQUk7S0FDakIsQ0FBQztJQUVGLDBCQUEwQjtJQUMxQixNQUFNLFNBQVMsR0FBRyxJQUFJLGVBQU0sQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxZQUFZLENBQUMsQ0FBQztJQUU5RCwwREFBMEQ7SUFDMUQsSUFBSSxnQkFBNkIsQ0FBQztJQUNsQyxJQUFJLEtBQUssRUFBRTtRQUNULGdCQUFnQixHQUFHLHFCQUFhLENBQUMsWUFBWSxFQUFFLEtBQUssQ0FBQyxDQUFDO0tBQ3ZEO1NBQU07UUFDTCxnQkFBZ0IsR0FBRyxZQUFZLENBQUM7S0FDakM7SUFFRCxnREFBZ0Q7SUFDaEQsTUFBTSxVQUFVLEdBQUcscUJBQWEsQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFLHNCQUFzQixFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUM7SUFFMUYsTUFBTSxZQUFZLEdBQUcsSUFBSSxlQUFNLENBQzdCLEtBQUssRUFDTCxFQUFFLEVBQ0YsVUFBVSxDQUNYLENBQUM7SUFFRiwyQkFBbUIsQ0FBQyxTQUFTLEVBQUU7UUFDN0I7WUFDRSxFQUFFLEVBQUUsS0FBSztZQUNULE1BQU0sRUFBRSxzQkFBc0I7U0FDL0I7S0FDRixDQUFDLENBQUM7SUFFSCxPQUFPLFlBQVksQ0FBQztBQUN0QixDQUFDO0FBM0NELDhDQTJDQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0Isc0JBQXNCLENBQUMsUUFBZ0I7SUFDckQsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQzdELE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQzNFLE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUM7QUFKRCx3REFJQztBQUVELG1CQUFtQjtBQUNuQixTQUFnQixVQUFVLENBQUMsS0FBWSxFQUFFLGVBQXdCLElBQUksRUFBRSxZQUEyQjtJQUNoRyxPQUFPLHFCQUFRLENBQUMsS0FBSyxFQUFFO1FBQ3JCLGVBQWUsRUFBRSxZQUFZLENBQUMsQ0FBQztZQUM3QiwyQ0FBNEIsRUFBRSxDQUFDLENBQUM7WUFDaEMsc0NBQXVCLEVBQUU7UUFDM0IsaUJBQWlCLEVBQUU7WUFDakIsa0JBQWtCLEVBQUUsSUFBSTtZQUN4QixnQkFBZ0IsRUFBRSxJQUFJO1lBQ3RCLFdBQVcsRUFBRSxHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQztTQUNwRDtRQUNELFlBQVk7S0FDYixDQUFDLENBQUM7QUFDTCxDQUFDO0FBWkQsZ0NBWUM7QUFFRCxTQUFnQixrQkFBa0IsQ0FBQyxLQUFnQixFQUFFLEVBQVU7SUFDN0QsT0FBTyxHQUFHLENBQUMsV0FBVyxDQUFDLGtCQUFrQixDQUN2QyxLQUFLLEVBQ0wsRUFBRSxFQUNGLHFGQUFxRixDQUN0RixDQUFDO0FBQ0osQ0FBQztBQU5ELGdEQU1DO0FBRUQsU0FBZ0IsbUNBQW1DLENBQUMsS0FBWSxFQUFFLFNBQWlCO0lBQ2pGLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUNsQyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLFNBQVMsRUFBRTtZQUMvQixNQUFNLGVBQWUsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQWdCLENBQUM7WUFDdkUsMkJBQW1CLENBQUMsZUFBZSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSwrQkFBK0IsRUFBQyxDQUFDLENBQUMsQ0FBQztZQUM5RiwyQkFBbUIsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLCtCQUErQixFQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzlGLDJCQUFtQixDQUFDLGVBQWUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsK0JBQStCLEVBQUMsQ0FBQyxDQUFDLENBQUM7U0FDL0Y7SUFDSCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFURCxrRkFTQztBQUVELFNBQWdCLGVBQWUsQ0FBQyxLQUFnQixFQUFFLEVBQVUsRUFBRSxHQUFhLEVBQUUsSUFBYTtJQUN4RixNQUFNLFNBQVMsR0FBRyxJQUFJLElBQUksMENBQW1CLEVBQUUsQ0FBQztJQUVoRCxtRUFBbUU7SUFDbkUsTUFBTSxXQUFXLEdBQUcsMkNBQXNCLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUMzRCxNQUFNLE9BQU8sR0FBRyxJQUFJLEdBQUcsQ0FBQyxhQUFhLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUU7UUFDNUQsR0FBRztRQUNILGdCQUFnQixFQUFFLElBQUk7S0FDdkIsQ0FBQyxDQUFDO0lBQ0gsMkJBQW1CLENBQUMsT0FBTyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxlQUFlLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDdkUsMkJBQW1CLENBQUMsT0FBTyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxlQUFlLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDdEUsMkJBQW1CLENBQUMsT0FBTyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxlQUFlLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFFdkUsTUFBTSxVQUFVLEdBQUc7UUFDakIsV0FBVyxFQUFFLEdBQUcsRUFBRSxjQUFjO1FBQ2hDLGFBQWEsRUFBRSxpQkFBaUI7UUFDaEMsTUFBTSxFQUFFLFdBQVc7UUFDbkIsYUFBYSxFQUFFLENBQUM7UUFDaEIsSUFBSSxFQUFFLFNBQVM7UUFDZixNQUFNLEVBQUUsVUFBVTtRQUNsQixtQkFBbUIsRUFBRSxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUM7UUFDOUMsb0JBQW9CLEVBQUUsV0FBVyxDQUFDLG9CQUFvQjtLQUN2RCxDQUFDO0lBRUYsTUFBTSxRQUFRLEdBQUcsSUFBSSxLQUFLLENBQUMsZUFBZSxDQUN4QyxLQUFLLEVBQ0wsR0FBRyxFQUFFLFVBQVUsRUFDZixVQUFVLENBQ1gsQ0FBQztJQUNGLFFBQVEsQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDcEMsT0FBTyxRQUFRLENBQUM7QUFDbEIsQ0FBQztBQS9CRCwwQ0ErQkM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFnQixxQ0FBcUMsQ0FBQyxLQUFZLEVBQUUsa0JBQTBCLEVBQUUsY0FBc0I7SUFDcEgsTUFBTSxRQUFRLEdBQUcscUJBQVEsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDM0MsTUFBTSxRQUFRLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxlQUFlLEVBQUU7UUFDdkQsVUFBVSxFQUFFO1lBQ1YsV0FBVyxFQUFFLGtCQUFLLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQztTQUN6QztLQUNGLENBQUMsQ0FBQztJQUVILE1BQU0sQ0FBRSxTQUFTLENBQUUsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzVDLHFCQUFRLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLHFCQUFxQixDQUFDLGtCQUFrQixFQUFFO1FBQ2xFLGNBQWMsRUFBRTtZQUNkLFlBQVksRUFBRTtnQkFDWixTQUFTO2dCQUNULEtBQUs7YUFDTjtTQUNGO0tBQ0YsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQWpCRCxzRkFpQkM7QUFFRCxTQUFnQixrQkFBa0IsQ0FBQyxLQUFZLEVBQUUsSUFBWSxFQUFFLEtBQWE7SUFDMUUsTUFBTSxpQkFBaUIsR0FBRyxxQkFBUSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQy9FLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzNELENBQUM7QUFIRCxnREFHQztBQUVELDBHQUEwRztBQUMxRyxNQUFNLGtCQUFrQjtJQUNmLEtBQUssQ0FBQyxJQUFnQjtRQUMzQixNQUFNLFFBQVEsR0FBRyxJQUFtQixDQUFDO1FBQ3JDLElBQUksUUFBUSxDQUFDLGVBQWUsS0FBSyx1QkFBdUIsRUFBRTtZQUN4RCwyQkFBbUIsQ0FBQyxRQUFRLEVBQUU7Z0JBQzVCLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsOEdBQThHLEVBQUU7Z0JBQ3JJLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsOEdBQThHLEVBQUU7Z0JBQ3JJLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsOEdBQThHLEVBQUU7YUFDdEksQ0FBQyxDQUFDO1NBQ0o7SUFDSCxDQUFDO0NBQ0Y7QUFFRCxTQUFnQixhQUFhLENBQUMsS0FBWSxFQUFFLEVBQVU7SUFDcEQsTUFBTSxjQUFjLEdBQUcsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsVUFBVSxFQUFFO1FBQ2pFLElBQUksRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLFNBQVMsU0FBUyxDQUFDO1FBQ2xELE9BQU8sRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLFdBQVc7UUFDbkMsT0FBTyxFQUFFLFVBQVU7S0FDcEIsQ0FBQyxDQUFDO0lBQ0gsMkJBQW1CLENBQUMsY0FBYyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxlQUFlLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDOUUsMkJBQW1CLENBQUMsY0FBYyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxlQUFlLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDOUUsMkJBQW1CLENBQUMsY0FBYyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxlQUFlLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFFOUUsTUFBTSxPQUFPLEdBQUcsSUFBSSxHQUFHLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFO1FBQ3ZELE9BQU8sRUFBRSxjQUFjO1FBQ3ZCLG9CQUFvQixFQUFFO1lBQ3BCLGlCQUFpQixFQUFFLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNO1lBQy9DLFVBQVUsRUFBRSxtQkFBbUIsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLGFBQWEsQ0FBQztTQUMzRDtLQUNGLENBQUMsQ0FBQztJQUVILE1BQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQztJQUMvQyxJQUFJLGFBQWEsRUFBRTtRQUNqQiwyQkFBbUIsQ0FBQyxhQUFhLEVBQUU7WUFDakMsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxlQUFlLEVBQUU7U0FDdkMsQ0FBQyxDQUFDO0tBQ0o7SUFFRCxNQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3JDLDJCQUFtQixDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsZUFBZSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3pFLE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDeEMsMkJBQW1CLENBQUMsWUFBWSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxlQUFlLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFFNUUsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQztJQUN6QywyQkFBbUIsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLGVBQWUsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN4RSwyQkFBbUIsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLGVBQWUsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUV4RSxPQUFPLE9BQU8sQ0FBQztBQUNqQixDQUFDO0FBbkNELHNDQW1DQztBQUVELFNBQWdCLG1CQUFtQixDQUFDLEtBQVksRUFBRSxFQUFVO0lBQzFELE1BQU0sTUFBTSxHQUFHLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLGNBQWMsRUFBRTtRQUM3RCxJQUFJLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxTQUFTLFNBQVMsQ0FBQztRQUNsRCxPQUFPLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXO1FBQ25DLE9BQU8sRUFBRSxVQUFVO0tBQ3BCLENBQUMsQ0FBQztJQUNILDJCQUFtQixDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsZUFBZSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3RFLDJCQUFtQixDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsZUFBZSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3RFLDJCQUFtQixDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsZUFBZSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBRXRFLE1BQU0sVUFBVSxHQUFHLElBQUksR0FBRyxDQUFDLGlCQUFpQixDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUU7UUFDdEQsT0FBTyxFQUFFLE1BQU07UUFDZixlQUFlLEVBQUUsQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQztLQUM5RCxDQUFDLENBQUM7SUFFSCxPQUFPLFVBQVUsQ0FBQztBQUNwQixDQUFDO0FBaEJELGtEQWdCQztBQUVELDRDQUE0QztBQUM1QyxvRUFBb0U7QUFDcEUsK0ZBQStGO0FBQy9GLDhEQUE4RDtBQUM5RCxTQUFnQix5QkFBeUIsQ0FBQyxJQUFZO0lBQ3BELE1BQU0sU0FBUyxHQUFHLGdCQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxnQkFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsR0FBRyxpQkFBRyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNqRSxNQUFNLFdBQVcsR0FBRyxnQkFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsZ0JBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUM7SUFDM0QsT0FBTyxnQkFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEVBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQztBQUM1QyxDQUFDO0FBSkQsOERBSUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBZ0IsNEJBQTRCLENBQUMsS0FBWTtJQUN2RCxxQkFBTyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxrQkFBa0IsRUFBRSxDQUFDLENBQUM7QUFDbEQsQ0FBQztBQUZELG9FQUVDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIikuIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqICB3aXRoIHRoZSBMaWNlbnNlLiBBIGNvcHkgb2YgdGhlIExpY2Vuc2UgaXMgbG9jYXRlZCBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogIG9yIGluIHRoZSAnbGljZW5zZScgZmlsZSBhY2NvbXBhbnlpbmcgdGhpcyBmaWxlLiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTXG4gKiAgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcbiAqICBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLy8gSW1wb3J0c1xuaW1wb3J0IHsgQ29uc3RydWN0LCBJQ29uc3RydWN0IH0gZnJvbSAnY29uc3RydWN0cyc7XG5pbXBvcnQgeyBCdWNrZXQsIEJ1Y2tldFByb3BzLCBCdWNrZXRFbmNyeXB0aW9uIH0gZnJvbSBcImF3cy1jZGstbGliL2F3cy1zM1wiO1xuaW1wb3J0IHsgQ2ZuUmVzb3VyY2UsIFJlbW92YWxQb2xpY3ksIFN0YWNrLCBBc3BlY3RzLCBJQXNwZWN0LCBBd3MsIEZuIH0gZnJvbSBcImF3cy1jZGstbGliXCI7XG5pbXBvcnQgeyBidWlsZFZwYyB9IGZyb20gJy4uL2xpYi92cGMtaGVscGVyJztcbmltcG9ydCB7IERlZmF1bHRQdWJsaWNQcml2YXRlVnBjUHJvcHMsIERlZmF1bHRJc29sYXRlZFZwY1Byb3BzIH0gZnJvbSAnLi4vbGliL3ZwYy1kZWZhdWx0cyc7XG5pbXBvcnQgeyBvdmVycmlkZVByb3BzLCBhZGRDZm5TdXBwcmVzc1J1bGVzIH0gZnJvbSBcIi4uL2xpYi91dGlsc1wiO1xuaW1wb3J0IHsgY3JlYXRlQ2FjaGVTdWJuZXRHcm91cCAgfSBmcm9tIFwiLi4vbGliL2VsYXN0aWNhY2hlLWhlbHBlclwiO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIGNhY2hlIGZyb20gJ2F3cy1jZGstbGliL2F3cy1lbGFzdGljYWNoZSc7XG5pbXBvcnQgKiBhcyBlYzIgZnJvbSAnYXdzLWNkay1saWIvYXdzLWVjMic7XG5pbXBvcnQgKiBhcyBhY20gZnJvbSAnYXdzLWNkay1saWIvYXdzLWNlcnRpZmljYXRlbWFuYWdlcic7XG5pbXBvcnQgeyBDZm5GdW5jdGlvbiB9IGZyb20gXCJhd3MtY2RrLWxpYi9hd3MtbGFtYmRhXCI7XG5pbXBvcnQgeyBHZXREZWZhdWx0Q2FjaGVQb3J0IH0gZnJvbSBcIi4uL2xpYi9lbGFzdGljYWNoZS1kZWZhdWx0c1wiO1xuaW1wb3J0IHsgTWF0Y2gsIFRlbXBsYXRlIH0gZnJvbSAnYXdzLWNkay1saWIvYXNzZXJ0aW9ucyc7XG5pbXBvcnQgKiBhcyBsYW1iZGEgZnJvbSBcImF3cy1jZGstbGliL2F3cy1sYW1iZGFcIjtcbmltcG9ydCAqIGFzIGFwaSBmcm9tIFwiYXdzLWNkay1saWIvYXdzLWFwaWdhdGV3YXlcIjtcblxuZXhwb3J0IGNvbnN0IGZha2VFY3JSZXBvQXJuID0gJ2Fybjphd3M6ZWNyOnVzLWVhc3QtMToxMjM0NTY3ODkwMTI6cmVwb3NpdG9yeS9mYWtlLXJlcG8nO1xuXG4vLyBDcmVhdGVzIGEgYnVja2V0IHVzZWQgZm9yIHRlc3RpbmcgLSBtaW5pbWFsIHByb3BlcnRpZXMsIGRlc3Ryb3llZCBhZnRlciB0ZXN0XG5leHBvcnQgZnVuY3Rpb24gQ3JlYXRlU2NyYXBCdWNrZXQoc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM/OiBCdWNrZXRQcm9wcyB8IGFueSkge1xuXG4gIGlmIChwcm9wcz8uc2VydmVyQWNjZXNzTG9nc0J1Y2tldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkRvbid0IHRyeSB0byBzZW5kIGEgbG9nIGJ1Y2tldCB0byBDcmVhdGVTY3JhcEJ1Y2tldFwiKTtcbiAgfVxuXG4gIC8vIEJhc2ljIHByb3BzIGZvciBzY3JhcCBhbmQgbG9nIGJ1Y2tldHNcbiAgY29uc3QgZGVmYXVsdFByb3BzOiBCdWNrZXRQcm9wcyA9IHtcbiAgICB2ZXJzaW9uZWQ6IHRydWUsXG4gICAgcmVtb3ZhbFBvbGljeTogUmVtb3ZhbFBvbGljeS5ERVNUUk9ZLFxuICAgIGF1dG9EZWxldGVPYmplY3RzOiB0cnVlLFxuICAgIGVuY3J5cHRpb246IEJ1Y2tldEVuY3J5cHRpb24uUzNfTUFOQUdFRCxcbiAgICBlbmZvcmNlU1NMOiB0cnVlXG4gIH07XG5cbiAgLy8gQ3JlYXRlIGJhc2ljIGxvZyBidWNrZXRcbiAgY29uc3QgbG9nQnVja2V0ID0gbmV3IEJ1Y2tldChzY29wZSwgYCR7aWR9TG9nYCwgZGVmYXVsdFByb3BzKTtcblxuICAvLyBDb21iaW5lIGJhc2ljIHByb3BzIHdpdGggc3BlY2lhbCBwcm9wcyBmcm9tIHRlc3QgY2xpZW50XG4gIGxldCBzeW50aGVzaXplZFByb3BzOiBCdWNrZXRQcm9wcztcbiAgaWYgKHByb3BzKSB7XG4gICAgc3ludGhlc2l6ZWRQcm9wcyA9IG92ZXJyaWRlUHJvcHMoZGVmYXVsdFByb3BzLCBwcm9wcyk7XG4gIH0gZWxzZSB7XG4gICAgc3ludGhlc2l6ZWRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiAgfVxuXG4gIC8vIEZpbmFsbHkgLSBzZXQgdXAgbG9nZ2luZyBmb3IgdGhlIHNjcmFwIGJ1Y2tldFxuICBjb25zdCBmaW5hbFByb3BzID0gb3ZlcnJpZGVQcm9wcyhzeW50aGVzaXplZFByb3BzLCB7IHNlcnZlckFjY2Vzc0xvZ3NCdWNrZXQ6IGxvZ0J1Y2tldCB9KTtcblxuICBjb25zdCBzY3JpcHRCdWNrZXQgPSBuZXcgQnVja2V0KFxuICAgIHNjb3BlLFxuICAgIGlkLFxuICAgIGZpbmFsUHJvcHNcbiAgKTtcblxuICBhZGRDZm5TdXBwcmVzc1J1bGVzKGxvZ0J1Y2tldCwgW1xuICAgIHtcbiAgICAgIGlkOiBcIlczNVwiLFxuICAgICAgcmVhc29uOiBcIlRoaXMgaXMgYSBsb2cgYnVja2V0XCIsXG4gICAgfVxuICBdKTtcblxuICByZXR1cm4gc2NyaXB0QnVja2V0O1xufVxuXG4vKipcbiAqIEBzdW1tYXJ5IENyZWF0ZXMgYSBzdGFjayBuYW1lIGZvciBJbnRlZ3JhdGlvbiB0ZXN0c1xuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lIC0gdGhlIGZpbGVuYW1lIG9mIHRoZSBpbnRlZyB0ZXN0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIGEgc3RyaW5nIHdpdGggY3VycmVudCBmaWxlbmFtZSBhZnRlciByZW1vdmluZyBhbnl0aGluZyBiZWZvcmUgdGhlIHByZWZpeCAnLicgYW5kIHN1ZmZpeCAnLmpzJ1xuICogZS5nLiAnaW50ZWcuYXBpZ2F0ZXdheS1keW5hbW9kYi1DUlVELmpzJyB3aWxsIHJldHVybiAnYXBpZ2F0ZXdheS1keW5hbW9kYi1DUlVEJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJbnRlZ1N0YWNrTmFtZShmaWxlbmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgZmlsZSA9IHBhdGguYmFzZW5hbWUoZmlsZW5hbWUsIHBhdGguZXh0bmFtZShmaWxlbmFtZSkpO1xuICBjb25zdCBzdGFja25hbWUgPSBmaWxlLnNsaWNlKGZpbGUubGFzdEluZGV4T2YoJy4nKSArIDEpLnJlcGxhY2UoL18vZywgJy0nKTtcbiAgcmV0dXJuIHN0YWNrbmFtZTtcbn1cblxuLy8gSGVscGVyIEZ1bmN0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRlc3RWcGMoc3RhY2s6IFN0YWNrLCBwdWJsaWNGYWNpbmc6IGJvb2xlYW4gPSB0cnVlLCB1c2VyVnBjUHJvcHM/OiBlYzIuVnBjUHJvcHMpIHtcbiAgcmV0dXJuIGJ1aWxkVnBjKHN0YWNrLCB7XG4gICAgZGVmYXVsdFZwY1Byb3BzOiBwdWJsaWNGYWNpbmcgP1xuICAgICAgRGVmYXVsdFB1YmxpY1ByaXZhdGVWcGNQcm9wcygpIDpcbiAgICAgIERlZmF1bHRJc29sYXRlZFZwY1Byb3BzKCksXG4gICAgY29uc3RydWN0VnBjUHJvcHM6IHtcbiAgICAgIGVuYWJsZURuc0hvc3RuYW1lczogdHJ1ZSxcbiAgICAgIGVuYWJsZURuc1N1cHBvcnQ6IHRydWUsXG4gICAgICBpcEFkZHJlc3NlczogZWMyLklwQWRkcmVzc2VzLmNpZHIoJzE3Mi4xNjguMC4wLzE2JyksXG4gICAgfSxcbiAgICB1c2VyVnBjUHJvcHNcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGYWtlQ2VydGlmaWNhdGUoc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZyk6IGFjbS5JQ2VydGlmaWNhdGUge1xuICByZXR1cm4gYWNtLkNlcnRpZmljYXRlLmZyb21DZXJ0aWZpY2F0ZUFybihcbiAgICBzY29wZSxcbiAgICBpZCxcbiAgICBcImFybjphd3M6YWNtOnVzLWVhc3QtMToxMjM0NTY3ODkwMTI6Y2VydGlmaWNhdGUvMTExMTIyMjItMzMzMy0xMjM0LTEyMzQtMTIzNDU2Nzg5MDEyXCJcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1cHByZXNzQ3VzdG9tSGFuZGxlckNmbk5hZ1dhcm5pbmdzKHN0YWNrOiBTdGFjaywgaGFuZGxlcklkOiBzdHJpbmcpIHtcbiAgc3RhY2subm9kZS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICBpZiAoY2hpbGQubm9kZS5pZCA9PT0gaGFuZGxlcklkKSB7XG4gICAgICBjb25zdCBoYW5kbGVyRnVuY3Rpb24gPSBjaGlsZC5ub2RlLmZpbmRDaGlsZCgnSGFuZGxlcicpIGFzIENmbkZ1bmN0aW9uO1xuICAgICAgYWRkQ2ZuU3VwcHJlc3NSdWxlcyhoYW5kbGVyRnVuY3Rpb24sIFt7IGlkOiBcIlc1OFwiLCByZWFzb246IFwiQ0RLIGdlbmVyYXRlZCBjdXN0b20gcmVzb3VyY2VcIn1dKTtcbiAgICAgIGFkZENmblN1cHByZXNzUnVsZXMoaGFuZGxlckZ1bmN0aW9uLCBbeyBpZDogXCJXODlcIiwgcmVhc29uOiBcIkNESyBnZW5lcmF0ZWQgY3VzdG9tIHJlc291cmNlXCJ9XSk7XG4gICAgICBhZGRDZm5TdXBwcmVzc1J1bGVzKGhhbmRsZXJGdW5jdGlvbiwgW3sgaWQ6IFwiVzkyXCIsIHJlYXNvbjogXCJDREsgZ2VuZXJhdGVkIGN1c3RvbSByZXNvdXJjZVwifV0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDcmVhdGVUZXN0Q2FjaGUoc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgdnBjOiBlYzIuSVZwYywgcG9ydD86IG51bWJlcikge1xuICBjb25zdCBjYWNoZVBvcnQgPSBwb3J0ID8/IEdldERlZmF1bHRDYWNoZVBvcnQoKTtcblxuICAvLyBDcmVhdGUgdGhlIHN1Ym5ldCBncm91cCBmcm9tIGFsbCB0aGUgaXNvbGF0ZWQgc3VibmV0cyBpbiB0aGUgVlBDXG4gIGNvbnN0IHN1Ym5ldEdyb3VwID0gY3JlYXRlQ2FjaGVTdWJuZXRHcm91cChzY29wZSwgdnBjLCBpZCk7XG4gIGNvbnN0IGVtcHR5U0cgPSBuZXcgZWMyLlNlY3VyaXR5R3JvdXAoc2NvcGUsIGAke2lkfS1jYWNoZXNnYCwge1xuICAgIHZwYyxcbiAgICBhbGxvd0FsbE91dGJvdW5kOiB0cnVlLFxuICB9KTtcbiAgYWRkQ2ZuU3VwcHJlc3NSdWxlcyhlbXB0eVNHLCBbeyBpZDogXCJXNDBcIiwgcmVhc29uOiBcIlRlc3QgUmVzb3VyY2VcIiB9XSk7XG4gIGFkZENmblN1cHByZXNzUnVsZXMoZW1wdHlTRywgW3sgaWQ6IFwiVzVcIiwgcmVhc29uOiBcIlRlc3QgUmVzb3VyY2VcIiB9XSk7XG4gIGFkZENmblN1cHByZXNzUnVsZXMoZW1wdHlTRywgW3sgaWQ6IFwiVzM2XCIsIHJlYXNvbjogXCJUZXN0IFJlc291cmNlXCIgfV0pO1xuXG4gIGNvbnN0IGNhY2hlUHJvcHMgPSB7XG4gICAgY2x1c3Rlck5hbWU6IGAke2lkfS1jZGstY2x1c3RlcmAsXG4gICAgY2FjaGVOb2RlVHlwZTogXCJjYWNoZS50My5tZWRpdW1cIixcbiAgICBlbmdpbmU6IFwibWVtY2FjaGVkXCIsXG4gICAgbnVtQ2FjaGVOb2RlczogMixcbiAgICBwb3J0OiBjYWNoZVBvcnQsXG4gICAgYXpNb2RlOiBcImNyb3NzLWF6XCIsXG4gICAgdnBjU2VjdXJpdHlHcm91cElkczogW2VtcHR5U0cuc2VjdXJpdHlHcm91cElkXSxcbiAgICBjYWNoZVN1Ym5ldEdyb3VwTmFtZTogc3VibmV0R3JvdXAuY2FjaGVTdWJuZXRHcm91cE5hbWUsXG4gIH07XG5cbiAgY29uc3QgbmV3Q2FjaGUgPSBuZXcgY2FjaGUuQ2ZuQ2FjaGVDbHVzdGVyKFxuICAgIHNjb3BlLFxuICAgIGAke2lkfS1jbHVzdGVyYCxcbiAgICBjYWNoZVByb3BzXG4gICk7XG4gIG5ld0NhY2hlLmFkZERlcGVuZGVuY3koc3VibmV0R3JvdXApO1xuICByZXR1cm4gbmV3Q2FjaGU7XG59XG5cbi8qKlxuICogQXNzZXJ0cyB0aGF0IGEgS01TIGtleSB3aXRoIGEgc3BlY2lmaWMgZGVzY3JpcHRpb24gZXhpc3RzIG9uIGEgcmVzb3VyY2VcbiAqXG4gKiBAcGFyYW0gc3RhY2sgVGhlIENsb3VkRm9ybWF0aW9uIFN0YWNrIHRoYXQgY29udGFpbnMgdGhlIHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIHBhcmVudFJlc291cmNlVHlwZSBUaGUgdHlwZSBvZiBDbG91ZEZvcm1hdGlvbiBSZXNvdXJjZSB0aGF0IHNob3VsZCBoYXZlIHRoZSBrZXkgc2V0IG9uIGl0LCBlLmcuLCBgQVdTOjpTTlM6OlRvcGljYCwgZXRjLi4uXG4gKiBAcGFyYW0gZGVzY3JpcHRpb24gVGhlIHZhbHVlIG9mIHRoZSBEZXNjcmlwdGlvbiBwcm9wZXJ0eSBvbiB0aGUgS01TIEtleVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwZWN0S21zS2V5QXR0YWNoZWRUb0NvcnJlY3RSZXNvdXJjZShzdGFjazogU3RhY2ssIHBhcmVudFJlc291cmNlVHlwZTogc3RyaW5nLCBrZXlEZXNjcmlwdGlvbjogc3RyaW5nKSB7XG4gIGNvbnN0IHRlbXBsYXRlID0gVGVtcGxhdGUuZnJvbVN0YWNrKHN0YWNrKTtcbiAgY29uc3QgcmVzb3VyY2UgPSB0ZW1wbGF0ZS5maW5kUmVzb3VyY2VzKCdBV1M6OktNUzo6S2V5Jywge1xuICAgIFByb3BlcnRpZXM6IHtcbiAgICAgIERlc2NyaXB0aW9uOiBNYXRjaC5leGFjdChrZXlEZXNjcmlwdGlvbilcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IFsgbG9naWNhbElkIF0gPSBPYmplY3Qua2V5cyhyZXNvdXJjZSk7XG4gIFRlbXBsYXRlLmZyb21TdGFjayhzdGFjaykuaGFzUmVzb3VyY2VQcm9wZXJ0aWVzKHBhcmVudFJlc291cmNlVHlwZSwge1xuICAgIEttc01hc3RlcktleUlkOiB7XG4gICAgICBcIkZuOjpHZXRBdHRcIjogW1xuICAgICAgICBsb2dpY2FsSWQsXG4gICAgICAgIFwiQXJuXCJcbiAgICAgIF1cbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwZWN0Tm9uZXhpc3RlbmNlKHN0YWNrOiBTdGFjaywgdHlwZTogc3RyaW5nLCBwcm9wczogb2JqZWN0KSB7XG4gIGNvbnN0IHNob3VsZEZpbmROb3RoaW5nID0gVGVtcGxhdGUuZnJvbVN0YWNrKHN0YWNrKS5maW5kUmVzb3VyY2VzKHR5cGUsIHByb3BzKTtcbiAgZXhwZWN0KE9iamVjdC5rZXlzKHNob3VsZEZpbmROb3RoaW5nKS5sZW5ndGgpLnRvRXF1YWwoMCk7XG59XG5cbi8vIHByaXZhdGUgaGVscGVyIGNsYXNzIHRvIHN1cHByZXNzIHRoZSBzdGFuZGFyZCBjZm4gbmFnIHdhcm5pbmdzIGZvciBsYW1iZGEgZnVuY3Rpb25zIHVzZWQgaW4gaW50ZWcgdGVzdHNcbmNsYXNzIENmbk5hZ0xhbWJkYUFzcGVjdCBpbXBsZW1lbnRzIElBc3BlY3Qge1xuICBwdWJsaWMgdmlzaXQobm9kZTogSUNvbnN0cnVjdCk6IHZvaWQge1xuICAgIGNvbnN0IHJlc291cmNlID0gbm9kZSBhcyBDZm5SZXNvdXJjZTtcbiAgICBpZiAocmVzb3VyY2UuY2ZuUmVzb3VyY2VUeXBlID09PSAnQVdTOjpMYW1iZGE6OkZ1bmN0aW9uJykge1xuICAgICAgYWRkQ2ZuU3VwcHJlc3NSdWxlcyhyZXNvdXJjZSwgW1xuICAgICAgICB7IGlkOiAnVzU4JywgcmVhc29uOiAnVGhpcyBMYW1iZGEgRnVuY3Rpb24gaXMgY3JlYXRlZCBmb3IgaW50ZWdyYXRpb24gdGVzdGluZyBwdXJwb3NlcyBvbmx5IGFuZCBpcyBub3QgcGFydCBvZiBhbiBhY3R1YWwgY29uc3RydWN0JyB9LFxuICAgICAgICB7IGlkOiAnVzg5JywgcmVhc29uOiAnVGhpcyBMYW1iZGEgRnVuY3Rpb24gaXMgY3JlYXRlZCBmb3IgaW50ZWdyYXRpb24gdGVzdGluZyBwdXJwb3NlcyBvbmx5IGFuZCBpcyBub3QgcGFydCBvZiBhbiBhY3R1YWwgY29uc3RydWN0JyB9LFxuICAgICAgICB7IGlkOiAnVzkyJywgcmVhc29uOiAnVGhpcyBMYW1iZGEgRnVuY3Rpb24gaXMgY3JlYXRlZCBmb3IgaW50ZWdyYXRpb24gdGVzdGluZyBwdXJwb3NlcyBvbmx5IGFuZCBpcyBub3QgcGFydCBvZiBhbiBhY3R1YWwgY29uc3RydWN0JyB9XG4gICAgICBdKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENyZWF0ZVRlc3RBcGkoc3RhY2s6IFN0YWNrLCBpZDogc3RyaW5nKTogYXBpLkxhbWJkYVJlc3RBcGkge1xuICBjb25zdCBsYW1iZGFGdW5jdGlvbiA9IG5ldyBsYW1iZGEuRnVuY3Rpb24oc3RhY2ssIGAke2lkfUZ1bmN0aW9uYCwge1xuICAgIGNvZGU6IGxhbWJkYS5Db2RlLmZyb21Bc3NldChgJHtfX2Rpcm5hbWV9L2xhbWJkYWApLFxuICAgIHJ1bnRpbWU6IGxhbWJkYS5SdW50aW1lLk5PREVKU18xNl9YLFxuICAgIGhhbmRsZXI6IFwiLmhhbmRsZXJcIixcbiAgfSk7XG4gIGFkZENmblN1cHByZXNzUnVsZXMobGFtYmRhRnVuY3Rpb24sIFt7IGlkOiBcIlc1OFwiLCByZWFzb246IFwiVGVzdCBSZXNvdXJjZVwiIH1dKTtcbiAgYWRkQ2ZuU3VwcHJlc3NSdWxlcyhsYW1iZGFGdW5jdGlvbiwgW3sgaWQ6IFwiVzg5XCIsIHJlYXNvbjogXCJUZXN0IFJlc291cmNlXCIgfV0pO1xuICBhZGRDZm5TdXBwcmVzc1J1bGVzKGxhbWJkYUZ1bmN0aW9uLCBbeyBpZDogXCJXOTJcIiwgcmVhc29uOiBcIlRlc3QgUmVzb3VyY2VcIiB9XSk7XG5cbiAgY29uc3QgcmVzdEFwaSA9IG5ldyBhcGkuTGFtYmRhUmVzdEFwaShzdGFjaywgYCR7aWR9QXBpYCwge1xuICAgIGhhbmRsZXI6IGxhbWJkYUZ1bmN0aW9uLFxuICAgIGRlZmF1bHRNZXRob2RPcHRpb25zOiB7XG4gICAgICBhdXRob3JpemF0aW9uVHlwZTogYXBpLkF1dGhvcml6YXRpb25UeXBlLkNVU1RPTSxcbiAgICAgIGF1dGhvcml6ZXI6IENyZWF0ZUFwaUF1dGhvcml6ZXIoc3RhY2ssIGAke2lkfS1hdXRob3JpemVyYClcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IG5ld0RlcGxveW1lbnQgPSByZXN0QXBpLmxhdGVzdERlcGxveW1lbnQ7XG4gIGlmIChuZXdEZXBsb3ltZW50KSB7XG4gICAgYWRkQ2ZuU3VwcHJlc3NSdWxlcyhuZXdEZXBsb3ltZW50LCBbXG4gICAgICB7IGlkOiBcIlc2OFwiLCByZWFzb246IFwiVGVzdCBSZXNvdXJjZVwiIH0sXG4gICAgXSk7XG4gIH1cblxuICBjb25zdCBuZXdNZXRob2QgPSByZXN0QXBpLm1ldGhvZHNbMF07XG4gIGFkZENmblN1cHByZXNzUnVsZXMobmV3TWV0aG9kLCBbeyBpZDogXCJXNTlcIiwgcmVhc29uOiBcIlRlc3QgUmVzb3VyY2VcIiB9XSk7XG4gIGNvbnN0IG5ld01ldGhvZFR3byA9IHJlc3RBcGkubWV0aG9kc1sxXTtcbiAgYWRkQ2ZuU3VwcHJlc3NSdWxlcyhuZXdNZXRob2RUd28sIFt7IGlkOiBcIlc1OVwiLCByZWFzb246IFwiVGVzdCBSZXNvdXJjZVwiIH1dKTtcblxuICBjb25zdCBuZXdTdGFnZSA9IHJlc3RBcGkuZGVwbG95bWVudFN0YWdlO1xuICBhZGRDZm5TdXBwcmVzc1J1bGVzKG5ld1N0YWdlLCBbeyBpZDogXCJXNjRcIiwgcmVhc29uOiBcIlRlc3QgUmVzb3VyY2VcIiB9XSk7XG4gIGFkZENmblN1cHByZXNzUnVsZXMobmV3U3RhZ2UsIFt7IGlkOiBcIlc2OVwiLCByZWFzb246IFwiVGVzdCBSZXNvdXJjZVwiIH1dKTtcblxuICByZXR1cm4gcmVzdEFwaTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENyZWF0ZUFwaUF1dGhvcml6ZXIoc3RhY2s6IFN0YWNrLCBpZDogc3RyaW5nKTogYXBpLklBdXRob3JpemVyIHtcbiAgY29uc3QgYXV0aEZuID0gbmV3IGxhbWJkYS5GdW5jdGlvbihzdGFjaywgYCR7aWR9QXV0aEZ1bmN0aW9uYCwge1xuICAgIGNvZGU6IGxhbWJkYS5Db2RlLmZyb21Bc3NldChgJHtfX2Rpcm5hbWV9L2xhbWJkYWApLFxuICAgIHJ1bnRpbWU6IGxhbWJkYS5SdW50aW1lLk5PREVKU18xNl9YLFxuICAgIGhhbmRsZXI6IFwiLmhhbmRsZXJcIixcbiAgfSk7XG4gIGFkZENmblN1cHByZXNzUnVsZXMoYXV0aEZuLCBbeyBpZDogXCJXNThcIiwgcmVhc29uOiBcIlRlc3QgUmVzb3VyY2VcIiB9XSk7XG4gIGFkZENmblN1cHByZXNzUnVsZXMoYXV0aEZuLCBbeyBpZDogXCJXODlcIiwgcmVhc29uOiBcIlRlc3QgUmVzb3VyY2VcIiB9XSk7XG4gIGFkZENmblN1cHByZXNzUnVsZXMoYXV0aEZuLCBbeyBpZDogXCJXOTJcIiwgcmVhc29uOiBcIlRlc3QgUmVzb3VyY2VcIiB9XSk7XG5cbiAgY29uc3QgYXV0aG9yaXplciA9IG5ldyBhcGkuUmVxdWVzdEF1dGhvcml6ZXIoc3RhY2ssIGlkLCB7XG4gICAgaGFuZGxlcjogYXV0aEZuLFxuICAgIGlkZW50aXR5U291cmNlczogW2FwaS5JZGVudGl0eVNvdXJjZS5oZWFkZXIoJ0F1dGhvcml6YXRpb24nKV1cbiAgfSk7XG5cbiAgcmV0dXJuIGF1dGhvcml6ZXI7XG59XG5cbi8vIENyZWF0ZSBhIHNob3J0LCB1bmlxdWUgdG8gdGhpcyBzdGFjayBuYW1lXG4vLyB0ZWNobmljYWxseSB0aGlzIGlzIG5vdCAxMDAlIE9LLCBhcyBpdCBvbmx5IHVzZXMgYSBwb3J0aW9uIG9mIHRoZVxuLy8gc3RhY2sgZ3VpZCAtIGJ1dCBpdCdzIGZvciB0ZXN0cyBvbmx5IHNvIGlmIHRoZSBsYXN0IHNlZ21lbnQgb2YgMiBzdGFjayBndWlkcyBjb2xsaWRlIHNvbWVkYXlcbi8vIChWRVJZIHVubGlrZWx5KSwganVzdCBydW5uaW5nIGFnYWluIHNob3VsZCB0YWtlIGNhcmUgb2YgaXQuXG5leHBvcnQgZnVuY3Rpb24gQ3JlYXRlU2hvcnRVbmlxdWVUZXN0TmFtZShzdHViOiBzdHJpbmcpIHtcbiAgY29uc3Qgc3RhY2tHdWlkID0gRm4uc2VsZWN0KDIsIEZuLnNwbGl0KCcvJywgYCR7QXdzLlNUQUNLX0lEfWApKTtcbiAgY29uc3QgZ3VpZFBvcnRpb24gPSBGbi5zZWxlY3QoNCwgRm4uc3BsaXQoJy0nLCBzdGFja0d1aWQpKTtcbiAgcmV0dXJuIEZuLmpvaW4oXCItXCIsIFtzdHViLCAgZ3VpZFBvcnRpb25dKTtcbn1cblxuLyoqXG4gKiBVc2VkIHRvIHN1cHByZXNzIGNmbiBuYWcgVzU4LCBXODksIGFuZCBXOTIgcnVsZXMgb24gbGFtYmRhIGludGVncmF0aW9uIHRlc3QgcmVzb3VyY2VzLlxuICpcbiAqIEBwYXJhbSBzdGFjayAtIFRoZSBzdGFjayB0byBzdXBwcmVzcyBjZm4gbmFnIGxhbWJkYSBydWxlcyBvblxuICovXG5leHBvcnQgZnVuY3Rpb24gU3VwcHJlc3NDZm5OYWdMYW1iZGFXYXJuaW5ncyhzdGFjazogU3RhY2spIHtcbiAgQXNwZWN0cy5vZihzdGFjaykuYWRkKG5ldyBDZm5OYWdMYW1iZGFBc3BlY3QoKSk7XG59XG4iXX0=