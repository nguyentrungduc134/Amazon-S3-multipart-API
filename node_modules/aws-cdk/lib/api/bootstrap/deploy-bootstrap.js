"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bootstrapVariantFromTemplate = exports.bootstrapVersionFromTemplate = exports.BootstrapStack = void 0;
const os = require("os");
const path = require("path");
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cxapi = require("@aws-cdk/cx-api");
const fs = require("fs-extra");
const bootstrap_props_1 = require("./bootstrap-props");
const logging = require("../../logging");
const aws_auth_1 = require("../aws-auth");
const deploy_stack_1 = require("../deploy-stack");
const toolkit_info_1 = require("../toolkit-info");
/**
 * A class to hold state around stack bootstrapping
 *
 * This class exists so we can break bootstrapping into 2 phases:
 *
 * ```ts
 * const current = BootstrapStack.lookup(...);
 * // ...
 * current.update(newTemplate, ...);
 * ```
 *
 * And do something in between the two phases (such as look at the
 * current bootstrap stack and doing something intelligent).
 */
class BootstrapStack {
    static async lookup(sdkProvider, environment, toolkitStackName) {
        toolkitStackName = toolkitStackName ?? toolkit_info_1.DEFAULT_TOOLKIT_STACK_NAME;
        const resolvedEnvironment = await sdkProvider.resolveEnvironment(environment);
        const sdk = (await sdkProvider.forEnvironment(resolvedEnvironment, aws_auth_1.Mode.ForWriting)).sdk;
        const currentToolkitInfo = await toolkit_info_1.ToolkitInfo.lookup(resolvedEnvironment, sdk, toolkitStackName);
        return new BootstrapStack(sdkProvider, sdk, resolvedEnvironment, toolkitStackName, currentToolkitInfo);
    }
    constructor(sdkProvider, sdk, resolvedEnvironment, toolkitStackName, currentToolkitInfo) {
        this.sdkProvider = sdkProvider;
        this.sdk = sdk;
        this.resolvedEnvironment = resolvedEnvironment;
        this.toolkitStackName = toolkitStackName;
        this.currentToolkitInfo = currentToolkitInfo;
    }
    get parameters() {
        return this.currentToolkitInfo.found ? this.currentToolkitInfo.bootstrapStack.parameters : {};
    }
    get terminationProtection() {
        return this.currentToolkitInfo.found ? this.currentToolkitInfo.bootstrapStack.terminationProtection : undefined;
    }
    async partition() {
        return (await this.sdk.currentAccount()).partition;
    }
    /**
     * Perform the actual deployment of a bootstrap stack, given a template and some parameters
     */
    async update(template, parameters, options) {
        if (this.currentToolkitInfo.found && !options.force) {
            // Safety checks
            const abortResponse = {
                noOp: true,
                outputs: {},
                stackArn: this.currentToolkitInfo.bootstrapStack.stackId,
            };
            // Validate that the bootstrap stack we're trying to replace is from the same variant as the one we're trying to deploy
            const currentVariant = this.currentToolkitInfo.variant;
            const newVariant = bootstrapVariantFromTemplate(template);
            if (currentVariant !== newVariant) {
                logging.warning(`Bootstrap stack already exists, containing '${currentVariant}'. Not overwriting it with a template containing '${newVariant}' (use --force if you intend to overwrite)`);
                return abortResponse;
            }
            // Validate that we're not downgrading the bootstrap stack
            const newVersion = bootstrapVersionFromTemplate(template);
            const currentVersion = this.currentToolkitInfo.version;
            if (newVersion < currentVersion) {
                logging.warning(`Bootstrap stack already at version ${currentVersion}. Not downgrading it to version ${newVersion} (use --force if you intend to downgrade)`);
                if (newVersion === 0) {
                    // A downgrade with 0 as target version means we probably have a new-style bootstrap in the account,
                    // and an old-style bootstrap as current target, which means the user probably forgot to put this flag in.
                    logging.warning('(Did you set the \'@aws-cdk/core:newStyleStackSynthesis\' feature flag in cdk.json?)');
                }
                return abortResponse;
            }
        }
        const outdir = await fs.mkdtemp(path.join(os.tmpdir(), 'cdk-bootstrap'));
        const builder = new cxapi.CloudAssemblyBuilder(outdir);
        const templateFile = `${this.toolkitStackName}.template.json`;
        await fs.writeJson(path.join(builder.outdir, templateFile), template, { spaces: 2 });
        builder.addArtifact(this.toolkitStackName, {
            type: cxschema.ArtifactType.AWS_CLOUDFORMATION_STACK,
            environment: cxapi.EnvironmentUtils.format(this.resolvedEnvironment.account, this.resolvedEnvironment.region),
            properties: {
                templateFile,
                terminationProtection: options.terminationProtection ?? false,
            },
        });
        const assembly = builder.buildAssembly();
        return (0, deploy_stack_1.deployStack)({
            stack: assembly.getStackByName(this.toolkitStackName),
            resolvedEnvironment: this.resolvedEnvironment,
            sdk: this.sdk,
            sdkProvider: this.sdkProvider,
            force: options.force,
            roleArn: options.roleArn,
            tags: options.tags,
            deploymentMethod: { method: 'change-set', execute: options.execute },
            parameters,
            usePreviousParameters: true,
            // Obviously we can't need a bootstrap stack to deploy a bootstrap stack
            toolkitInfo: toolkit_info_1.ToolkitInfo.bootstraplessDeploymentsOnly(this.sdk),
        });
    }
}
exports.BootstrapStack = BootstrapStack;
function bootstrapVersionFromTemplate(template) {
    const versionSources = [
        template.Outputs?.[bootstrap_props_1.BOOTSTRAP_VERSION_OUTPUT]?.Value,
        template.Resources?.[bootstrap_props_1.BOOTSTRAP_VERSION_RESOURCE]?.Properties?.Value,
    ];
    for (const vs of versionSources) {
        if (typeof vs === 'number') {
            return vs;
        }
        if (typeof vs === 'string' && !isNaN(parseInt(vs, 10))) {
            return parseInt(vs, 10);
        }
    }
    return 0;
}
exports.bootstrapVersionFromTemplate = bootstrapVersionFromTemplate;
function bootstrapVariantFromTemplate(template) {
    return template.Parameters?.[bootstrap_props_1.BOOTSTRAP_VARIANT_PARAMETER]?.Default ?? bootstrap_props_1.DEFAULT_BOOTSTRAP_VARIANT;
}
exports.bootstrapVariantFromTemplate = bootstrapVariantFromTemplate;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwbG95LWJvb3RzdHJhcC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImRlcGxveS1ib290c3RyYXAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QiwyREFBMkQ7QUFDM0QseUNBQXlDO0FBQ3pDLCtCQUErQjtBQUMvQix1REFBOEs7QUFDOUsseUNBQXlDO0FBQ3pDLDBDQUFzRDtBQUN0RCxrREFBaUU7QUFDakUsa0RBQTBFO0FBRTFFOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFDSCxNQUFhLGNBQWM7SUFDbEIsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsV0FBd0IsRUFBRSxXQUE4QixFQUFFLGdCQUF5QjtRQUM1RyxnQkFBZ0IsR0FBRyxnQkFBZ0IsSUFBSSx5Q0FBMEIsQ0FBQztRQUVsRSxNQUFNLG1CQUFtQixHQUFHLE1BQU0sV0FBVyxDQUFDLGtCQUFrQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzlFLE1BQU0sR0FBRyxHQUFHLENBQUMsTUFBTSxXQUFXLENBQUMsY0FBYyxDQUFDLG1CQUFtQixFQUFFLGVBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztRQUV6RixNQUFNLGtCQUFrQixHQUFHLE1BQU0sMEJBQVcsQ0FBQyxNQUFNLENBQUMsbUJBQW1CLEVBQUUsR0FBRyxFQUFFLGdCQUFnQixDQUFDLENBQUM7UUFFaEcsT0FBTyxJQUFJLGNBQWMsQ0FBQyxXQUFXLEVBQUUsR0FBRyxFQUFFLG1CQUFtQixFQUFFLGdCQUFnQixFQUFFLGtCQUFrQixDQUFDLENBQUM7SUFDekcsQ0FBQztJQUVELFlBQ21CLFdBQXdCLEVBQ3hCLEdBQVMsRUFDVCxtQkFBc0MsRUFDdEMsZ0JBQXdCLEVBQ3hCLGtCQUErQjtRQUovQixnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUN4QixRQUFHLEdBQUgsR0FBRyxDQUFNO1FBQ1Qsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFtQjtRQUN0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RUYsS0FBSyxNQUFNLEVBQUUsSUFBSSxjQUFjLEVBQUU7UUFDL0IsSUFBSSxPQUFPLEVBQUUsS0FBSyxRQUFRLEVBQUU7WUFBRSxPQUFPLEVBQUUsQ0FBQztTQUFFO1FBQzFDLElBQUksT0FBTyxFQUFFLEtBQUssUUFBUSxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRTtZQUN0RCxPQUFPLFFBQVEsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7U0FDekI7S0FDRjtJQUNELE9BQU8sQ0FBQyxDQUFDO0FBQ1gsQ0FBQztBQWJELG9FQWFDO0FBRUQsU0FBZ0IsNEJBQTRCLENBQUMsUUFBYTtJQUN4RCxPQUFPLFFBQVEsQ0FBQyxVQUFVLEVBQUUsQ0FBQyw2Q0FBMkIsQ0FBQyxFQUFFLE9BQU8sSUFBSSwyQ0FBeUIsQ0FBQztBQUNsRyxDQUFDO0FBRkQsb0VBRUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBvcyBmcm9tICdvcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgY3hzY2hlbWEgZnJvbSAnQGF3cy1jZGsvY2xvdWQtYXNzZW1ibHktc2NoZW1hJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgeyBCT09UU1RSQVBfVkVSU0lPTl9PVVRQVVQsIEJvb3RzdHJhcEVudmlyb25tZW50T3B0aW9ucywgQk9PVFNUUkFQX1ZFUlNJT05fUkVTT1VSQ0UsIEJPT1RTVFJBUF9WQVJJQU5UX1BBUkFNRVRFUiwgREVGQVVMVF9CT09UU1RSQVBfVkFSSUFOVCB9IGZyb20gJy4vYm9vdHN0cmFwLXByb3BzJztcbmltcG9ydCAqIGFzIGxvZ2dpbmcgZnJvbSAnLi4vLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBNb2RlLCBTZGtQcm92aWRlciwgSVNESyB9IGZyb20gJy4uL2F3cy1hdXRoJztcbmltcG9ydCB7IGRlcGxveVN0YWNrLCBEZXBsb3lTdGFja1Jlc3VsdCB9IGZyb20gJy4uL2RlcGxveS1zdGFjayc7XG5pbXBvcnQgeyBERUZBVUxUX1RPT0xLSVRfU1RBQ0tfTkFNRSwgVG9vbGtpdEluZm8gfSBmcm9tICcuLi90b29sa2l0LWluZm8nO1xuXG4vKipcbiAqIEEgY2xhc3MgdG8gaG9sZCBzdGF0ZSBhcm91bmQgc3RhY2sgYm9vdHN0cmFwcGluZ1xuICpcbiAqIFRoaXMgY2xhc3MgZXhpc3RzIHNvIHdlIGNhbiBicmVhayBib290c3RyYXBwaW5nIGludG8gMiBwaGFzZXM6XG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IGN1cnJlbnQgPSBCb290c3RyYXBTdGFjay5sb29rdXAoLi4uKTtcbiAqIC8vIC4uLlxuICogY3VycmVudC51cGRhdGUobmV3VGVtcGxhdGUsIC4uLik7XG4gKiBgYGBcbiAqXG4gKiBBbmQgZG8gc29tZXRoaW5nIGluIGJldHdlZW4gdGhlIHR3byBwaGFzZXMgKHN1Y2ggYXMgbG9vayBhdCB0aGVcbiAqIGN1cnJlbnQgYm9vdHN0cmFwIHN0YWNrIGFuZCBkb2luZyBzb21ldGhpbmcgaW50ZWxsaWdlbnQpLlxuICovXG5leHBvcnQgY2xhc3MgQm9vdHN0cmFwU3RhY2sge1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIGxvb2t1cChzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsIGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCwgdG9vbGtpdFN0YWNrTmFtZT86IHN0cmluZykge1xuICAgIHRvb2xraXRTdGFja05hbWUgPSB0b29sa2l0U3RhY2tOYW1lID8/IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FO1xuXG4gICAgY29uc3QgcmVzb2x2ZWRFbnZpcm9ubWVudCA9IGF3YWl0IHNka1Byb3ZpZGVyLnJlc29sdmVFbnZpcm9ubWVudChlbnZpcm9ubWVudCk7XG4gICAgY29uc3Qgc2RrID0gKGF3YWl0IHNka1Byb3ZpZGVyLmZvckVudmlyb25tZW50KHJlc29sdmVkRW52aXJvbm1lbnQsIE1vZGUuRm9yV3JpdGluZykpLnNkaztcblxuICAgIGNvbnN0IGN1cnJlbnRUb29sa2l0SW5mbyA9IGF3YWl0IFRvb2xraXRJbmZvLmxvb2t1cChyZXNvbHZlZEVudmlyb25tZW50LCBzZGssIHRvb2xraXRTdGFja05hbWUpO1xuXG4gICAgcmV0dXJuIG5ldyBCb290c3RyYXBTdGFjayhzZGtQcm92aWRlciwgc2RrLCByZXNvbHZlZEVudmlyb25tZW50LCB0b29sa2l0U3RhY2tOYW1lLCBjdXJyZW50VG9vbGtpdEluZm8pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2RrOiBJU0RLLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcmVzb2x2ZWRFbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsXG4gICAgcHJpdmF0ZSByZWFkb25seSB0b29sa2l0U3RhY2tOYW1lOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBjdXJyZW50VG9vbGtpdEluZm86IFRvb2xraXRJbmZvKSB7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHBhcmFtZXRlcnMoKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFRvb2xraXRJbmZvLmZvdW5kID8gdGhpcy5jdXJyZW50VG9vbGtpdEluZm8uYm9vdHN0cmFwU3RhY2sucGFyYW1ldGVycyA6IHt9O1xuICB9XG5cbiAgcHVibGljIGdldCB0ZXJtaW5hdGlvblByb3RlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFRvb2xraXRJbmZvLmZvdW5kID8gdGhpcy5jdXJyZW50VG9vbGtpdEluZm8uYm9vdHN0cmFwU3RhY2sudGVybWluYXRpb25Qcm90ZWN0aW9uIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHBhcnRpdGlvbigpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHJldHVybiAoYXdhaXQgdGhpcy5zZGsuY3VycmVudEFjY291bnQoKSkucGFydGl0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gdGhlIGFjdHVhbCBkZXBsb3ltZW50IG9mIGEgYm9vdHN0cmFwIHN0YWNrLCBnaXZlbiBhIHRlbXBsYXRlIGFuZCBzb21lIHBhcmFtZXRlcnNcbiAgICovXG4gIHB1YmxpYyBhc3luYyB1cGRhdGUoXG4gICAgdGVtcGxhdGU6IGFueSxcbiAgICBwYXJhbWV0ZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+LFxuICAgIG9wdGlvbnM6IE9taXQ8Qm9vdHN0cmFwRW52aXJvbm1lbnRPcHRpb25zLCAncGFyYW1ldGVycyc+LFxuICApOiBQcm9taXNlPERlcGxveVN0YWNrUmVzdWx0PiB7XG4gICAgaWYgKHRoaXMuY3VycmVudFRvb2xraXRJbmZvLmZvdW5kICYmICFvcHRpb25zLmZvcmNlKSB7XG4gICAgICAvLyBTYWZldHkgY2hlY2tzXG4gICAgICBjb25zdCBhYm9ydFJlc3BvbnNlID0ge1xuICAgICAgICBub09wOiB0cnVlLFxuICAgICAgICBvdXRwdXRzOiB7fSxcbiAgICAgICAgc3RhY2tBcm46IHRoaXMuY3VycmVudFRvb2xraXRJbmZvLmJvb3RzdHJhcFN0YWNrLnN0YWNrSWQsXG4gICAgICB9O1xuXG4gICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBib290c3RyYXAgc3RhY2sgd2UncmUgdHJ5aW5nIHRvIHJlcGxhY2UgaXMgZnJvbSB0aGUgc2FtZSB2YXJpYW50IGFzIHRoZSBvbmUgd2UncmUgdHJ5aW5nIHRvIGRlcGxveVxuICAgICAgY29uc3QgY3VycmVudFZhcmlhbnQgPSB0aGlzLmN1cnJlbnRUb29sa2l0SW5mby52YXJpYW50O1xuICAgICAgY29uc3QgbmV3VmFyaWFudCA9IGJvb3RzdHJhcFZhcmlhbnRGcm9tVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgaWYgKGN1cnJlbnRWYXJpYW50ICE9PSBuZXdWYXJpYW50KSB7XG4gICAgICAgIGxvZ2dpbmcud2FybmluZyhgQm9vdHN0cmFwIHN0YWNrIGFscmVhZHkgZXhpc3RzLCBjb250YWluaW5nICcke2N1cnJlbnRWYXJpYW50fScuIE5vdCBvdmVyd3JpdGluZyBpdCB3aXRoIGEgdGVtcGxhdGUgY29udGFpbmluZyAnJHtuZXdWYXJpYW50fScgKHVzZSAtLWZvcmNlIGlmIHlvdSBpbnRlbmQgdG8gb3ZlcndyaXRlKWApO1xuICAgICAgICByZXR1cm4gYWJvcnRSZXNwb25zZTtcbiAgICAgIH1cblxuICAgICAgLy8gVmFsaWRhdGUgdGhhdCB3ZSdyZSBub3QgZG93bmdyYWRpbmcgdGhlIGJvb3RzdHJhcCBzdGFja1xuICAgICAgY29uc3QgbmV3VmVyc2lvbiA9IGJvb3RzdHJhcFZlcnNpb25Gcm9tVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgY29uc3QgY3VycmVudFZlcnNpb24gPSB0aGlzLmN1cnJlbnRUb29sa2l0SW5mby52ZXJzaW9uO1xuICAgICAgaWYgKG5ld1ZlcnNpb24gPCBjdXJyZW50VmVyc2lvbikge1xuICAgICAgICBsb2dnaW5nLndhcm5pbmcoYEJvb3RzdHJhcCBzdGFjayBhbHJlYWR5IGF0IHZlcnNpb24gJHtjdXJyZW50VmVyc2lvbn0uIE5vdCBkb3duZ3JhZGluZyBpdCB0byB2ZXJzaW9uICR7bmV3VmVyc2lvbn0gKHVzZSAtLWZvcmNlIGlmIHlvdSBpbnRlbmQgdG8gZG93bmdyYWRlKWApO1xuICAgICAgICBpZiAobmV3VmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgIC8vIEEgZG93bmdyYWRlIHdpdGggMCBhcyB0YXJnZXQgdmVyc2lvbiBtZWFucyB3ZSBwcm9iYWJseSBoYXZlIGEgbmV3LXN0eWxlIGJvb3RzdHJhcCBpbiB0aGUgYWNjb3VudCxcbiAgICAgICAgICAvLyBhbmQgYW4gb2xkLXN0eWxlIGJvb3RzdHJhcCBhcyBjdXJyZW50IHRhcmdldCwgd2hpY2ggbWVhbnMgdGhlIHVzZXIgcHJvYmFibHkgZm9yZ290IHRvIHB1dCB0aGlzIGZsYWcgaW4uXG4gICAgICAgICAgbG9nZ2luZy53YXJuaW5nKCcoRGlkIHlvdSBzZXQgdGhlIFxcJ0Bhd3MtY2RrL2NvcmU6bmV3U3R5bGVTdGFja1N5bnRoZXNpc1xcJyBmZWF0dXJlIGZsYWcgaW4gY2RrLmpzb24/KScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhYm9ydFJlc3BvbnNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG91dGRpciA9IGF3YWl0IGZzLm1rZHRlbXAocGF0aC5qb2luKG9zLnRtcGRpcigpLCAnY2RrLWJvb3RzdHJhcCcpKTtcbiAgICBjb25zdCBidWlsZGVyID0gbmV3IGN4YXBpLkNsb3VkQXNzZW1ibHlCdWlsZGVyKG91dGRpcik7XG4gICAgY29uc3QgdGVtcGxhdGVGaWxlID0gYCR7dGhpcy50b29sa2l0U3RhY2tOYW1lfS50ZW1wbGF0ZS5qc29uYDtcbiAgICBhd2FpdCBmcy53cml0ZUpzb24ocGF0aC5qb2luKGJ1aWxkZXIub3V0ZGlyLCB0ZW1wbGF0ZUZpbGUpLCB0ZW1wbGF0ZSwgeyBzcGFjZXM6IDIgfSk7XG5cbiAgICBidWlsZGVyLmFkZEFydGlmYWN0KHRoaXMudG9vbGtpdFN0YWNrTmFtZSwge1xuICAgICAgdHlwZTogY3hzY2hlbWEuQXJ0aWZhY3RUeXBlLkFXU19DTE9VREZPUk1BVElPTl9TVEFDSyxcbiAgICAgIGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudFV0aWxzLmZvcm1hdCh0aGlzLnJlc29sdmVkRW52aXJvbm1lbnQuYWNjb3VudCwgdGhpcy5yZXNvbHZlZEVudmlyb25tZW50LnJlZ2lvbiksXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHRlbXBsYXRlRmlsZSxcbiAgICAgICAgdGVybWluYXRpb25Qcm90ZWN0aW9uOiBvcHRpb25zLnRlcm1pbmF0aW9uUHJvdGVjdGlvbiA/PyBmYWxzZSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBhc3NlbWJseSA9IGJ1aWxkZXIuYnVpbGRBc3NlbWJseSgpO1xuXG4gICAgcmV0dXJuIGRlcGxveVN0YWNrKHtcbiAgICAgIHN0YWNrOiBhc3NlbWJseS5nZXRTdGFja0J5TmFtZSh0aGlzLnRvb2xraXRTdGFja05hbWUpLFxuICAgICAgcmVzb2x2ZWRFbnZpcm9ubWVudDogdGhpcy5yZXNvbHZlZEVudmlyb25tZW50LFxuICAgICAgc2RrOiB0aGlzLnNkayxcbiAgICAgIHNka1Byb3ZpZGVyOiB0aGlzLnNka1Byb3ZpZGVyLFxuICAgICAgZm9yY2U6IG9wdGlvbnMuZm9yY2UsXG4gICAgICByb2xlQXJuOiBvcHRpb25zLnJvbGVBcm4sXG4gICAgICB0YWdzOiBvcHRpb25zLnRhZ3MsXG4gICAgICBkZXBsb3ltZW50TWV0aG9kOiB7IG1ldGhvZDogJ2NoYW5nZS1zZXQnLCBleGVjdXRlOiBvcHRpb25zLmV4ZWN1dGUgfSxcbiAgICAgIHBhcmFtZXRlcnMsXG4gICAgICB1c2VQcmV2aW91c1BhcmFtZXRlcnM6IHRydWUsXG4gICAgICAvLyBPYnZpb3VzbHkgd2UgY2FuJ3QgbmVlZCBhIGJvb3RzdHJhcCBzdGFjayB0byBkZXBsb3kgYSBib290c3RyYXAgc3RhY2tcbiAgICAgIHRvb2xraXRJbmZvOiBUb29sa2l0SW5mby5ib290c3RyYXBsZXNzRGVwbG95bWVudHNPbmx5KHRoaXMuc2RrKSxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYm9vdHN0cmFwVmVyc2lvbkZyb21UZW1wbGF0ZSh0ZW1wbGF0ZTogYW55KTogbnVtYmVyIHtcbiAgY29uc3QgdmVyc2lvblNvdXJjZXMgPSBbXG4gICAgdGVtcGxhdGUuT3V0cHV0cz8uW0JPT1RTVFJBUF9WRVJTSU9OX09VVFBVVF0/LlZhbHVlLFxuICAgIHRlbXBsYXRlLlJlc291cmNlcz8uW0JPT1RTVFJBUF9WRVJTSU9OX1JFU09VUkNFXT8uUHJvcGVydGllcz8uVmFsdWUsXG4gIF07XG5cbiAgZm9yIChjb25zdCB2cyBvZiB2ZXJzaW9uU291cmNlcykge1xuICAgIGlmICh0eXBlb2YgdnMgPT09ICdudW1iZXInKSB7IHJldHVybiB2czsgfVxuICAgIGlmICh0eXBlb2YgdnMgPT09ICdzdHJpbmcnICYmICFpc05hTihwYXJzZUludCh2cywgMTApKSkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHZzLCAxMCk7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYm9vdHN0cmFwVmFyaWFudEZyb21UZW1wbGF0ZSh0ZW1wbGF0ZTogYW55KTogc3RyaW5nIHtcbiAgcmV0dXJuIHRlbXBsYXRlLlBhcmFtZXRlcnM/LltCT09UU1RSQVBfVkFSSUFOVF9QQVJBTUVURVJdPy5EZWZhdWx0ID8/IERFRkFVTFRfQk9PVFNUUkFQX1ZBUklBTlQ7XG59XG4iXX0=